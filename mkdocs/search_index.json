{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n. It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.\n\n\nAbout Fire.js\n\n\nFire.js is the Node.js bindings for ArrayFire, it uses \nCMake.js\n as of its build system. It takes Node.js ridiculous level of productivity and mix that with ArrayFire ridiculous level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).\n\n\nInstall instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with \n\"Sync\"\n (eg. \nsqrtSync\n). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a \nBluebird promise\n, ends with \n\"Async\"\n (eg. \nsqrtAsync\n). Wrap an \nES6 generator function\n by a \ncoroutine\n, and you can yield those promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have! (Of course you can use some other coroutine library, like \nco\n.)\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nAPI\n\n\nIn Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.\n\n\nAll asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with \nAsync\n and \nSync\n endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.\n\n\nSmall Example\n\n\nPort of the PI calculator from \nArrayFire documentation\n:\n\n\nC++\n\n\n// sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum\nfloat\n(dist \n 1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);\n\n\n\n\nJavaScript\n\n\nconst numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);\n\n\n\n\nIt's included in the \nexamples folder\n. To run on:\n\n\n\n\nio.js, enter: \niojs examples/es6/bechmarks/pi.js\n\n\nNode.js 0.12 or above, enter: \nnode --harmony examples/es6/bechmarks/pi.js\n\n\nNode.js below 0.12, enter: \nnode examples/es5/bechmarks/pi.js\n\n\n\n\nLicense\n\n\nApache 2.0\n\n\nCopyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken\n\nLicensed under the Apache License, Version 2.0 (the \nLicense\n);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \nAS IS\n BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome . It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-firejs", 
            "text": "Fire.js is the Node.js bindings for ArrayFire, it uses  CMake.js  as of its build system. It takes Node.js ridiculous level of productivity and mix that with ArrayFire ridiculous level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).  Install instructions can be found in the  project's readme at Github .", 
            "title": "About Fire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with  \"Sync\"  (eg.  sqrtSync ). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a  Bluebird promise , ends with  \"Async\"  (eg.  sqrtAsync ). Wrap an  ES6 generator function  by a  coroutine , and you can yield those promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have! (Of course you can use some other coroutine library, like  co .)  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#api", 
            "text": "In Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.  All asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with  Async  and  Sync  endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.", 
            "title": "API"
        }, 
        {
            "location": "/#small-example", 
            "text": "Port of the PI calculator from  ArrayFire documentation :  C++  // sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum float (dist   1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);  JavaScript  const numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);  It's included in the  examples folder . To run on:   io.js, enter:  iojs examples/es6/bechmarks/pi.js  Node.js 0.12 or above, enter:  node --harmony examples/es6/bechmarks/pi.js  Node.js below 0.12, enter:  node examples/es5/bechmarks/pi.js", 
            "title": "Small Example"
        }, 
        {
            "location": "/#license", 
            "text": "Apache 2.0  Copyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken\n\nLicensed under the Apache License, Version 2.0 (the  License );\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an  AS IS  BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/dtype/", 
            "text": "", 
            "title": "dtype"
        }, 
        {
            "location": "/source/", 
            "text": "", 
            "title": "source"
        }, 
        {
            "location": "/AFArray/", 
            "text": "AFArray class\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\nasynchronous, counterparts: \ncreateAsync\n, \ncreateSync\n\n\nCreates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the \nsource\n argument specifies its location.\n\n\n\n\ncreate(dim0, buffer, source, callback)\n: \ntemplate\ntypename T> array (dim_t dim0, const T *pointer, af::source src=afHost)\n\n\ncreate(dim0, dim1, buffer, source, callback)\n: \ntemplate\ntypename T>    array (dim_t dim0, dim_t dim1, const T *pointer, af::source src=afHost)\n\n\ncreate(dim0, dim1, dim2, buffer, source, callback)\n: \ntemplate\ntypename T> array (dim_t dim0, dim_t dim1, dim_t dim2, const T *pointer, af::source src=afHost)\n\n\ncreate(dim0, dim1, dim2, dim3, buffer, source, callback)\n: \ntemplate\ntypename T> array (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, const T *pointer, af::source src=afHost)\n\n\ncreate(dim0, dim1, dim2, dim4, buffer, source, callback)\n: [template\ntypename T>\n    array (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, const T *pointer, af::source src=afHost)] (http://www.arrayfire.com/docs/group\nconstruct\nmat.htm#gaaa8fab98447367bc4eaf3d7bc61d8ff5)\n\n\ncreate(dims, buffer, source, callback)\n: \ntemplate\n array (const dim4 \ndims, const T *pointer, af::source src=afHost)\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim4: Number\n - size of the dimension\n\n\ndims: Array|Dim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of source\n - can be one of the values of \nsource\n object (eg. \nsource.host\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nconstructor\n\n\nArrays could be created as empty ones or by having a specified dimensions and element type. \n\n\n\n\nnew AFArray()\n: \narray ()\n\n\nnew AFArray(dim0, type)\n: \narray (dim_t dim0, dtype ty=f32)\n\n\nnew AFArray(dim0, dim1, type)\n: \narray (dim_t dim0, dim_t dim1, dtype ty=f32)\n\n\nnew AFArray(dim0, dim1, dim2, type)\n: \narray (dim_t dim0, dim_t dim1, dim_t dim2, dtype ty=f32)\n\n\nnew AFArray(dim0, dim1, dim2, dim3, type)\n: \narray (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, dtype ty=f32)\n\n\nnew AFArray(dims, type)\n: \narray (const dim4 \ndims, dtype ty=f32)\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim4: Number\n - size of the dimension\n\n\ndims: Array|Dim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of dType\n - can be one of the values of \ndType\n object (eg. \ndType.f32\n)\n\n\n\n\nRemarks:\n\n\nIn Fire.js \ntype\n argument is \nnot optional\n.\n\n\nMethods\n\n\nelements()\n\n\nGet the number of elements in array.\n\n\n\n\nelements()\n: \ndim_t  elements () const\n\n\n\n\nResult:\n Number\n\n\nhost()\n\n\nCopy array data to host.\n\n\nasynchronous, counterparts: \nhostAsync\n, \nhostSync\n\n\n\n\nhost(callback)\n: \ntemplate\ntypename T> T * host () const\n\n\nhost(buffer, callback)\n: \nvoid   host (void *ptr) const\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - to hold array's values, must be atleast the size of the array.\n\n\n\n\nResult:\n if buffer is not specified, then it will be created and returned, otherwise the result is \nundefined\n\n\ncopyToHost()\n\n\nalias of \nhost\n\n\ntype\n\n\ndims\n\n\nnumdims\n\n\nnumDims\n\n\nbytes\n\n\ncopy\n\n\nisempty\n\n\nisEmpty\n\n\nisscalar\n\n\nisScalar\n\n\nisvector\n\n\nisVector\n\n\nisrow\n\n\nisRow\n\n\niscolumn\n\n\nisColumn\n\n\niscomplex\n\n\nisComplex\n\n\nisreal\n\n\nisReal\n\n\nisdouble\n\n\nisDouble\n\n\nissingle\n\n\nisSingle\n\n\nisrealfloating\n\n\nisRealFloating\n\n\nisfloating\n\n\nisFloating\n\n\nisinteger\n\n\nisInteger\n\n\nisbool\n\n\nisBool\n\n\neval\n\n\nIndexing Operations\n\n\nat\n\n\nrow\n\n\ncol\n\n\nslice\n\n\nrows\n\n\ncols\n\n\nslices\n\n\nOperators\n\n\nas\n\n\nassign\n\n\nset\n\n\nadd\n\n\naddAssign\n\n\nsub\n\n\nsubAssign\n\n\nmul\n\n\nmulAssign\n\n\ndiv\n\n\ndivAssign\n\n\nbitshiftl\n\n\nbitShiftL\n\n\nbitshiftr\n\n\nbitShiftR\n\n\nlt\n\n\ngt\n\n\nle\n\n\nge\n\n\neq\n\n\nneq\n\n\nand\n\n\nor\n\n\nneg\n\n\nnot\n\n\nbitAnd\n\n\nbitOr\n\n\nbitXor", 
            "title": "AFArray"
        }, 
        {
            "location": "/AFArray/#afarray-class", 
            "text": "", 
            "title": "AFArray class"
        }, 
        {
            "location": "/AFArray/#staitc-methods", 
            "text": "AFArray.create()  asynchronous, counterparts:  createAsync ,  createSync  Creates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the  source  argument specifies its location.   create(dim0, buffer, source, callback) :  template typename T> array (dim_t dim0, const T *pointer, af::source src=afHost)  create(dim0, dim1, buffer, source, callback) :  template typename T>    array (dim_t dim0, dim_t dim1, const T *pointer, af::source src=afHost)  create(dim0, dim1, dim2, buffer, source, callback) :  template typename T> array (dim_t dim0, dim_t dim1, dim_t dim2, const T *pointer, af::source src=afHost)  create(dim0, dim1, dim2, dim3, buffer, source, callback) :  template typename T> array (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, const T *pointer, af::source src=afHost)  create(dim0, dim1, dim2, dim4, buffer, source, callback) : [template typename T>\n    array (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, const T *pointer, af::source src=afHost)] (http://www.arrayfire.com/docs/group construct mat.htm#gaaa8fab98447367bc4eaf3d7bc61d8ff5)  create(dims, buffer, source, callback) :  template  array (const dim4  dims, const T *pointer, af::source src=afHost)   Arguments:   dim0 .. dim4: Number  - size of the dimension  dims: Array|Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of source  - can be one of the values of  source  object (eg.  source.host )   Result : the created AFArray instance.", 
            "title": "Staitc methods"
        }, 
        {
            "location": "/AFArray/#constructor", 
            "text": "Arrays could be created as empty ones or by having a specified dimensions and element type.    new AFArray() :  array ()  new AFArray(dim0, type) :  array (dim_t dim0, dtype ty=f32)  new AFArray(dim0, dim1, type) :  array (dim_t dim0, dim_t dim1, dtype ty=f32)  new AFArray(dim0, dim1, dim2, type) :  array (dim_t dim0, dim_t dim1, dim_t dim2, dtype ty=f32)  new AFArray(dim0, dim1, dim2, dim3, type) :  array (dim_t dim0, dim_t dim1, dim_t dim2, dim_t dim3, dtype ty=f32)  new AFArray(dims, type) :  array (const dim4  dims, dtype ty=f32)   Arguments:   dim0 .. dim4: Number  - size of the dimension  dims: Array|Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of dType  - can be one of the values of  dType  object (eg.  dType.f32 )   Remarks:  In Fire.js  type  argument is  not optional .", 
            "title": "constructor"
        }, 
        {
            "location": "/AFArray/#methods", 
            "text": "elements()  Get the number of elements in array.   elements() :  dim_t  elements () const   Result:  Number  host()  Copy array data to host.  asynchronous, counterparts:  hostAsync ,  hostSync   host(callback) :  template typename T> T * host () const  host(buffer, callback) :  void   host (void *ptr) const   Arguments:   buffer: Buffer  - to hold array's values, must be atleast the size of the array.   Result:  if buffer is not specified, then it will be created and returned, otherwise the result is  undefined  copyToHost()  alias of  host  type  dims  numdims  numDims  bytes  copy  isempty  isEmpty  isscalar  isScalar  isvector  isVector  isrow  isRow  iscolumn  isColumn  iscomplex  isComplex  isreal  isReal  isdouble  isDouble  issingle  isSingle  isrealfloating  isRealFloating  isfloating  isFloating  isinteger  isInteger  isbool  isBool  eval", 
            "title": "Methods"
        }, 
        {
            "location": "/AFArray/#indexing-operations", 
            "text": "at  row  col  slice  rows  cols  slices", 
            "title": "Indexing Operations"
        }, 
        {
            "location": "/AFArray/#operators", 
            "text": "as  assign  set  add  addAssign  sub  subAssign  mul  mulAssign  div  divAssign  bitshiftl  bitShiftL  bitshiftr  bitShiftR  lt  gt  le  ge  eq  neq  and  or  neg  not  bitAnd  bitOr  bitXor", 
            "title": "Operators"
        }, 
        {
            "location": "/devices/", 
            "text": "Head 1\n\n\nHead 2\n\n\nHead 3", 
            "title": "Managing Devices"
        }, 
        {
            "location": "/devices/#head-1", 
            "text": "", 
            "title": "Head 1"
        }, 
        {
            "location": "/devices/#head-2", 
            "text": "", 
            "title": "Head 2"
        }, 
        {
            "location": "/devices/#head-3", 
            "text": "", 
            "title": "Head 3"
        }
    ]
}