{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n. It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.\n\n\nAbout ArrayFire.js\n\n\nArrayFire.js is the Node.js bindings for ArrayFire, it uses \nCMake.js\n as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).\n\n\nInstall instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous ArrayFire.js method has two counterparts. One synchronous, ends with \n\"Sync\"\n (eg. \nsqrtSync\n). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a \nBluebird promise\n, ends with \n\"Async\"\n (eg. \nsqrtAsync\n). Wrap an \nES6 generator function\n by a \ncoroutine\n, and you can yield those promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have! (Of course you can use some other coroutine library, like \nco\n.)\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. ArrayFire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nAPI\n\n\nIn ArrayFire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.\n\n\nAll asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with \nAsync\n and \nSync\n endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.\n\n\nSmall Example\n\n\nPort of the PI calculator from \nArrayFire documentation\n:\n\n\nC++\n\n\n// sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum\nfloat\n(dist \n 1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);\n\n\n\n\nJavaScript\n\n\nconst numberOfPoints = 20000000;\n\n// ...\n\nlet x = af.randu(numberOfPoints, af.types.dtype.f32);\nlet y = af.randu(numberOfPoints, af.types.dtype.f32);\nlet dist = af.sqrt(x.mul(x).add(y.mul(y)));\nlet numInside = yield af.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  numInside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);\n\n\n\n\nIt's included in the \nexamples folder\n. To run on:\n\n\n\n\nio.js, enter: \niojs examples/es6/bechmarks/pi.js\n\n\nNode.js 0.12 or above, enter: \nnode --harmony examples/es6/bechmarks/pi.js\n\n\nNode.js below 0.12, enter: \nnode examples/es5/bechmarks/pi.js\n\n\n\n\nLicense\n\n\nNew BSD", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome . It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-arrayfirejs", 
            "text": "ArrayFire.js is the Node.js bindings for ArrayFire, it uses  CMake.js  as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).  Install instructions can be found in the  project's readme at Github .", 
            "title": "About ArrayFire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous ArrayFire.js method has two counterparts. One synchronous, ends with  \"Sync\"  (eg.  sqrtSync ). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a  Bluebird promise , ends with  \"Async\"  (eg.  sqrtAsync ). Wrap an  ES6 generator function  by a  coroutine , and you can yield those promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have! (Of course you can use some other coroutine library, like  co .)  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. ArrayFire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#api", 
            "text": "In ArrayFire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.  All asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with  Async  and  Sync  endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.", 
            "title": "API"
        }, 
        {
            "location": "/#small-example", 
            "text": "Port of the PI calculator from  ArrayFire documentation :  C++  // sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum float (dist   1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);  JavaScript  const numberOfPoints = 20000000;\n\n// ...\n\nlet x = af.randu(numberOfPoints, af.types.dtype.f32);\nlet y = af.randu(numberOfPoints, af.types.dtype.f32);\nlet dist = af.sqrt(x.mul(x).add(y.mul(y)));\nlet numInside = yield af.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  numInside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);  It's included in the  examples folder . To run on:   io.js, enter:  iojs examples/es6/bechmarks/pi.js  Node.js 0.12 or above, enter:  node --harmony examples/es6/bechmarks/pi.js  Node.js below 0.12, enter:  node examples/es5/bechmarks/pi.js", 
            "title": "Small Example"
        }, 
        {
            "location": "/#license", 
            "text": "New BSD", 
            "title": "License"
        }, 
        {
            "location": "/statics/", 
            "text": "Static Objects\n\n\nThey are accessible from the main Fire.js context object, eg.:\n\n\nvar fire = require(\nfire-js\n)(\nCPU\n);\n\n// dType:\nvar dType = fire.types.dType;\n\n\n\n\ntypes.dType\n\n\nalias: \ntypes.dtype\n\n\n{\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}\n\n\n\n\ntypes.source\n\n\n{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}\n\n\n\n\ntypes.matchType\n\n\n{\n    SAD: 0,     // Match based on Sum of Absolute Differences (SAD)\n    zSAD: 1,    // Match based on Zero mean SAD.\n    lSAD: 2,    // Match based on Locally scaled SAD.\n    SSD: 3,     // Match based on Sum of Squared Differences (SSD)\n    zSSD: 4,    // Match based on Zero mean SSD.\n    lSSD: 5,    // Match based on Locally scaled SSD.\n    NCC: 6,     // Match based on Normalized Cross Correlation (NCC)\n    zNCC: 7,    // Match based on Zero mean NCC.\n    SHD: 8,     // Match based on Sum of Hamming Distances (SHD)\n    // ArrayFire convention compatible aliases:\n    AF_SAD: 0,\n    AF_ZSAD: 1,\n    AF_LSAD: 2,\n    AF_SSD: 3,\n    AF_ZSSD: 4,\n    AF_LSSD: 5,\n    AF_NCC: 6,\n    AF_ZNCC: 7,\n    AF_SHD: 8\n}", 
            "title": "Statics"
        }, 
        {
            "location": "/statics/#static-objects", 
            "text": "They are accessible from the main Fire.js context object, eg.:  var fire = require( fire-js )( CPU );\n\n// dType:\nvar dType = fire.types.dType;", 
            "title": "Static Objects"
        }, 
        {
            "location": "/statics/#typesdtype", 
            "text": "alias:  types.dtype  {\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}", 
            "title": "types.dType"
        }, 
        {
            "location": "/statics/#typessource", 
            "text": "{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "types.source"
        }, 
        {
            "location": "/statics/#typesmatchtype", 
            "text": "{\n    SAD: 0,     // Match based on Sum of Absolute Differences (SAD)\n    zSAD: 1,    // Match based on Zero mean SAD.\n    lSAD: 2,    // Match based on Locally scaled SAD.\n    SSD: 3,     // Match based on Sum of Squared Differences (SSD)\n    zSSD: 4,    // Match based on Zero mean SSD.\n    lSSD: 5,    // Match based on Locally scaled SSD.\n    NCC: 6,     // Match based on Normalized Cross Correlation (NCC)\n    zNCC: 7,    // Match based on Zero mean NCC.\n    SHD: 8,     // Match based on Sum of Hamming Distances (SHD)\n    // ArrayFire convention compatible aliases:\n    AF_SAD: 0,\n    AF_ZSAD: 1,\n    AF_LSAD: 2,\n    AF_SSD: 3,\n    AF_ZSSD: 4,\n    AF_LSSD: 5,\n    AF_NCC: 6,\n    AF_ZNCC: 7,\n    AF_SHD: 8\n}", 
            "title": "types.matchType"
        }, 
        {
            "location": "/AFArray/", 
            "text": "AFArray class\n\n\n-\n ArrayFire Documentation\n\n\n\n\n\n\n\n\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\n\n\n\n\nconstructor\n\n\nMethods\n\n\nelements()\n\n\nhost()\n\n\ncopyToHost()\n\n\nscalar()\n\n\nvalue()\n\n\nwrite()\n\n\ntype()\n\n\ndims()\n\n\nnumdims()\n\n\nnumDims()\n\n\nbytes()\n\n\nas()\n\n\ncopy()\n\n\nisempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()\n\n\neval()\n\n\n\n\n\n\nIndexing Operations\n\n\nat()\n\n\nrow(), rows()\n\n\ncol(), cols()\n\n\nslice(), slices()\n\n\n\n\n\n\nAssignment Operators\n\n\nArithmetic Operators\n\n\nLogical Operators\n\n\n\n\n\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\nasynchronous, counterparts: \ncreateAsync\n, \ncreateSync\n\n\nCreates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the \nsource\n argument specifies its location.\n\n\n\n\ncreate(dim0, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim3, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dims, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nconstructor\n\n\nArrays could be created as empty ones or by having a specified dimensions and element type. \n\n\n\n\nnew AFArray()\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nRemarks:\n\n\nIn Fire.js \ntype\n argument is \nnot optional\n.\n\n\nMethods\n\n\nelements()\n\n\nGet the number of elements in array.\n\n\n\n\nelements()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n Number\n\n\nhost()\n\n\nCopy array data to host.\n\n\nasynchronous, counterparts: \nhostAsync\n, \nhostSync\n\n\n\n\nhost(callback)\n \n-\n ArrayFire Documentation\n\n\nhost(buffer, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - to hold array's values, must be atleast the size of the array.\n\n\n\n\nResult:\n if buffer is not specified, then it will be created and returned, otherwise the result is \nundefined\n\n\ncopyToHost()\n\n\nalias of \nhost\n\n\nscalar()\n\n\nasynchronous, counterparts: \nscalarAsync\n, \nscalarSync\n\n\nGet scalar value from the array (if its size is larger than one in any dimensions it gives the first value).\n\n\n\n\nscalar(callback)\n\n\n\n\nResult: Boolean|Number|String|\nComplex\n value in the array, type depends on the array's type.\n\n\nvalue()\n\n\nalias of \nscalar()\n\n\nwrite()\n\n\nPerform deep copy from host/device pointer to an existing array.\n\n\n\n\nwrite(buffer, bytesToCopy, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - data to copy to the array, or device pointer created by the \nalloc\n method.\n\n\nbytesToCopy\n: bytes to copy\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\ntype()\n\n\n\n\ntype()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's element type, can be one of the values of \ndType\n object\n\n\ndims()\n\n\n\n\ndims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's dimensions info in a \nDim4\n object instance\n\n\nnumdims()\n\n\n\n\nnumdims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n number of dimensions of the array\n\n\nnumDims()\n\n\nalias of \nnumdims\n\n\nbytes()\n\n\n\n\nbytes()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n size of the array in bytes\n\n\nas()\n\n\nConverts the array into another type. \n\n\n\n\nas(type)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult:\n AFArray instance holding reference the converted array\n\n\ncopy())`\n\n\n\n\ncopy()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n new AFArray instance holding a deep copy of the array\n\n\nisempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()\n\n\naliases respectively: \nisEmpty\n, \nisScalar\n, \nisVector\n, \nisRow\n, \nisColumn\n, \nisComplex\n, \nisReal\n, \nisDouble\n, \nisSingle\n, \nisRealFloating\n, \nisFloating\n, \nisInteger\n, \nisBool\n \n\n\n\n\nis\nanything\n() \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n actual type info (Boolean)\n\n\neval()\n\n\n\n\neval()\n \n-\n ArrayFire Documentation\n\n\n\n\nEvaluate any JIT expressions to generate data for the array.\n\n\nIndexing Operations\n\n\nat()\n\n\n-\n ArrayFire Documentation\n\n\n\n\nat(s0)\n\n\nat(s0, s1)\n\n\nat(s0, s1, s2)\n\n\nat(s0, s1, s2, s3)\n\n\n\n\nArguments\n:\n\n\n\n\n\n\ns0 .. s3: null|String|Number|\nSeq\n|AFArray\n \n\n\n\n\nnull:\n means \n\"span\"\n\n\nString:\n can be \n\"span\"\n\n\nNumber:\n element's index, or -1 which means the last element\n\n\nSeq\n:\n sequence of values\n\n\nAFArray:\n array holding the index value\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding reference to the the specified region of the original array\n\n\nrow(), rows()\n\n\nGets a reference of a row in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nrow(index)\n\n\nrows(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a row index or a range of row indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\ncol(), cols()\n\n\nGets a reference of a column in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\ncol(index)\n\n\ncols(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a column index or a range of column indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\nslice(), slices()\n\n\nGets a reference of a matrix in a 3D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nslice(index)\n\n\nslices(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a matrix index or a range of matrix indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 3D array\n\n\nAssignment Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nassign(other)\n operator =\n\n\nset(other)\n operator = (alias of assign)\n\n\naddAssign(other)\n operator +=\n\n\nsubAssign(other)\n operator -=\n\n\nmulAssign(other)\n operator *=\n\n\ndivAssign(other)\n operator /=\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n assignee AFArray instance\n\n\nArithmetic Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nadd(other)\n operator +\n\n\nsub(other)\n operator -\n\n\nmul(other)\n operator *\n\n\ndiv(other)\n operator /\n\n\nbitshiftl(other)\n operator \n\n\nbitShiftL(other)\n operator \n (alias of bitshiftl)\n\n\nbitshiftr(other)\n operator \n\n\nbitShiftR(other)\n operator \n (alias of bitshiftr)\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result\n\n\nLogical Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nneg()\n operator -\n\n\nnot()\n operator !\n\n\nlt(other)\n operator \n\n\ngt(other)\n operator \n\n\nle(other)\n operator \n=\n\n\nge(other)\n operator \n=\n\n\neq(other)\n operator ==\n\n\nneq(other)\n operator !=\n\n\nand(other)\n operator \n\n\nor(other)\n operator ||\n\n\nbitAnd(other)\n operator \n\n\nbitOr(other)\n operator |\n\n\nbitXor(other)\n operator ^\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result", 
            "title": "AFArray"
        }, 
        {
            "location": "/AFArray/#afarray-class", 
            "text": "-  ArrayFire Documentation     Staitc methods  AFArray.create()    constructor  Methods  elements()  host()  copyToHost()  scalar()  value()  write()  type()  dims()  numdims()  numDims()  bytes()  as()  copy()  isempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()  eval()    Indexing Operations  at()  row(), rows()  col(), cols()  slice(), slices()    Assignment Operators  Arithmetic Operators  Logical Operators", 
            "title": "AFArray class"
        }, 
        {
            "location": "/AFArray/#staitc-methods", 
            "text": "AFArray.create()  asynchronous, counterparts:  createAsync ,  createSync  Creates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the  source  argument specifies its location.   create(dim0, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim3, type, buffer, source, callback)   -  ArrayFire Documentation  create(dims, buffer, source, callback)   -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of  source  - can be one of the values of source object (eg.  source.host )   Result : the created AFArray instance.", 
            "title": "Staitc methods"
        }, 
        {
            "location": "/AFArray/#constructor", 
            "text": "Arrays could be created as empty ones or by having a specified dimensions and element type.    new AFArray() :  -  ArrayFire Documentation  new AFArray(dim0, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  new AFArray(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Remarks:  In Fire.js  type  argument is  not optional .", 
            "title": "constructor"
        }, 
        {
            "location": "/AFArray/#methods", 
            "text": "elements()  Get the number of elements in array.   elements()   -  ArrayFire Documentation   Result:  Number  host()  Copy array data to host.  asynchronous, counterparts:  hostAsync ,  hostSync   host(callback)   -  ArrayFire Documentation  host(buffer, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - to hold array's values, must be atleast the size of the array.   Result:  if buffer is not specified, then it will be created and returned, otherwise the result is  undefined  copyToHost()  alias of  host  scalar()  asynchronous, counterparts:  scalarAsync ,  scalarSync  Get scalar value from the array (if its size is larger than one in any dimensions it gives the first value).   scalar(callback)   Result: Boolean|Number|String| Complex  value in the array, type depends on the array's type.  value()  alias of  scalar()  write()  Perform deep copy from host/device pointer to an existing array.   write(buffer, bytesToCopy, source, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - data to copy to the array, or device pointer created by the  alloc  method.  bytesToCopy : bytes to copy  source: value of  source  - can be one of the values of source object (eg.  source.host )   type()   type()   -  ArrayFire Documentation   Result:  array's element type, can be one of the values of  dType  object  dims()   dims()   -  ArrayFire Documentation   Result:  array's dimensions info in a  Dim4  object instance  numdims()   numdims()   -  ArrayFire Documentation   Result:  number of dimensions of the array  numDims()  alias of  numdims  bytes()   bytes()   -  ArrayFire Documentation   Result:  size of the array in bytes  as()  Converts the array into another type.    as(type)   -  ArrayFire Documentation   Arguments:   type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result:  AFArray instance holding reference the converted array  copy())`   copy()   -  ArrayFire Documentation   Result:  new AFArray instance holding a deep copy of the array  isempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()  aliases respectively:  isEmpty ,  isScalar ,  isVector ,  isRow ,  isColumn ,  isComplex ,  isReal ,  isDouble ,  isSingle ,  isRealFloating ,  isFloating ,  isInteger ,  isBool     is anything ()  -  ArrayFire Documentation   Result:  actual type info (Boolean)  eval()   eval()   -  ArrayFire Documentation   Evaluate any JIT expressions to generate data for the array.", 
            "title": "Methods"
        }, 
        {
            "location": "/AFArray/#indexing-operations", 
            "text": "at()  -  ArrayFire Documentation   at(s0)  at(s0, s1)  at(s0, s1, s2)  at(s0, s1, s2, s3)   Arguments :    s0 .. s3: null|String|Number| Seq |AFArray     null:  means  \"span\"  String:  can be  \"span\"  Number:  element's index, or -1 which means the last element  Seq :  sequence of values  AFArray:  array holding the index value     Result:  AFArray instance holding reference to the the specified region of the original array  row(), rows()  Gets a reference of a row in a 2D AFArray.  -  ArrayFire Documentation   row(index)  rows(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a row index or a range of row indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  col(), cols()  Gets a reference of a column in a 2D AFArray.  -  ArrayFire Documentation   col(index)  cols(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a column index or a range of column indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  slice(), slices()  Gets a reference of a matrix in a 3D AFArray.  -  ArrayFire Documentation   slice(index)  slices(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a matrix index or a range of matrix indices   Result:  AFArray instance holding reference to the specified region of the original 3D array", 
            "title": "Indexing Operations"
        }, 
        {
            "location": "/AFArray/#assignment-operators", 
            "text": "-  ArrayFire Documentation   assign(other)  operator =  set(other)  operator = (alias of assign)  addAssign(other)  operator +=  subAssign(other)  operator -=  mulAssign(other)  operator *=  divAssign(other)  operator /=   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  assignee AFArray instance", 
            "title": "Assignment Operators"
        }, 
        {
            "location": "/AFArray/#arithmetic-operators", 
            "text": "-  ArrayFire Documentation   add(other)  operator +  sub(other)  operator -  mul(other)  operator *  div(other)  operator /  bitshiftl(other)  operator   bitShiftL(other)  operator   (alias of bitshiftl)  bitshiftr(other)  operator   bitShiftR(other)  operator   (alias of bitshiftr)   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result", 
            "title": "Arithmetic Operators"
        }, 
        {
            "location": "/AFArray/#logical-operators", 
            "text": "-  ArrayFire Documentation   neg()  operator -  not()  operator !  lt(other)  operator   gt(other)  operator   le(other)  operator  =  ge(other)  operator  =  eq(other)  operator ==  neq(other)  operator !=  and(other)  operator   or(other)  operator ||  bitAnd(other)  operator   bitOr(other)  operator |  bitXor(other)  operator ^   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result", 
            "title": "Logical Operators"
        }, 
        {
            "location": "/Dim4/", 
            "text": "Dim4 class\n\n\nconstructors\n\n\n\n\nnew Dim4(dimArray)\n\n\nnew Dim4(dim0, dim1, dim2, dim3)\n\n\n\n\nArguments\n:\n\n\n\n\ndimArray: Array\n - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]\n\n\ndim0 .. dim3: Number\n - size of the dimension, default is 1\n\n\n\n\nProperties\n\n\ndims\n\n\nValue:\n \nArray\n containing the dimension sizes, eg.: two dimensions = \n[2, 3, 1, 1]\n, four dimensions = \n[2, 3, 4, 5]\n\n\nndims\n\n\nalias: \nnDims\n\n\nValue:\n number of dimensions\n\n\nelements\n\n\nValue:\n number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Dim4"
        }, 
        {
            "location": "/Dim4/#dim4-class", 
            "text": "", 
            "title": "Dim4 class"
        }, 
        {
            "location": "/Dim4/#constructors", 
            "text": "new Dim4(dimArray)  new Dim4(dim0, dim1, dim2, dim3)   Arguments :   dimArray: Array  - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]  dim0 .. dim3: Number  - size of the dimension, default is 1", 
            "title": "constructors"
        }, 
        {
            "location": "/Dim4/#properties", 
            "text": "dims  Value:   Array  containing the dimension sizes, eg.: two dimensions =  [2, 3, 1, 1] , four dimensions =  [2, 3, 4, 5]  ndims  alias:  nDims  Value:  number of dimensions  elements  Value:  number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Properties"
        }, 
        {
            "location": "/Seq/", 
            "text": "Seq class\n\n\nconstructors\n\n\n\n\nnew Seq(begin, end)\n\n\nnew Seq(begin, end, step)\n\n\n\n\nArguments\n:\n\n\n\n\nbegin: Number\n - begin of sequence values\n\n\nend: Number\n - end of sequence values\n\n\nstep: Number\n - step size (default is 1)\n\n\n\n\nProperties\n\n\nbegin\n\n\nValue:\n begin of sequence values\n\n\nend\n\n\nValue:\n end of sequence values\n\n\nstep\n\n\nValue:\n step size", 
            "title": "Seq"
        }, 
        {
            "location": "/Seq/#seq-class", 
            "text": "", 
            "title": "Seq class"
        }, 
        {
            "location": "/Seq/#constructors", 
            "text": "new Seq(begin, end)  new Seq(begin, end, step)   Arguments :   begin: Number  - begin of sequence values  end: Number  - end of sequence values  step: Number  - step size (default is 1)", 
            "title": "constructors"
        }, 
        {
            "location": "/Seq/#properties", 
            "text": "begin  Value:  begin of sequence values  end  Value:  end of sequence values  step  Value:  step size", 
            "title": "Properties"
        }, 
        {
            "location": "/Complex/", 
            "text": "Complex class\n\n\nconstructor\n\n\n\n\nnew Complex(real, imag)\n\n\n\n\nArguments\n:\n\n\n\n\nreal: Number\n - real part of the value\n\n\nimag: Number\n - imaginary part of the value\n\n\n\n\nProperties\n\n\nreal\n\n\nValue:\n real part of the value\n\n\nimag\n\n\nValue:\n imaginary part of the value", 
            "title": "Complex"
        }, 
        {
            "location": "/Complex/#complex-class", 
            "text": "", 
            "title": "Complex class"
        }, 
        {
            "location": "/Complex/#constructor", 
            "text": "new Complex(real, imag)   Arguments :   real: Number  - real part of the value  imag: Number  - imaginary part of the value", 
            "title": "constructor"
        }, 
        {
            "location": "/Complex/#properties", 
            "text": "real  Value:  real part of the value  imag  Value:  imaginary part of the value", 
            "title": "Properties"
        }, 
        {
            "location": "/devices/", 
            "text": "Platform and Device managing\n\n\n-\n ArrayFire Documentation\n\n\n\n\n\n\n\n\n\n\nSelecting Platform\n\n\ngetDeviceCount()\n\n\ngetDevices()\n\n\ngetDevice()\n\n\nsetDevice()\n\n\ndeviceInfo()\n\n\nisDoubleAvailable()\n\n\nsync()\n\n\nwait()\n\n\nalloc()\n\n\npinned()\n\n\n\n\n\n\n\nSelecting Platform\n\n\nFire.js platform can be selected by calling the root function with the appropriate platform ID as an argument.\n\n\nSupported platform IDs:\n\n\n\n\nCPU\n (cpu fallback)\n\n\nOpenCL\n\n\nCUDA\n\n\n\n\nExample:\n\n\nvar fire = require(\nfire-js\n);\nvar cpuPlatform = fire(\nCPU\n);\n\n\n\n\ngetDeviceCount()\n\n\nGets the number of devices on the given platform.\n\n\n\n\ngetDeviceCount()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: Number\n - number of devices\n\n\nExample:\n\n\nvar fire = require(\nfire-js\n);\nvar cpuPlatform = fire(\nCPU\n);\nvar deviceCount = cpuPlatform.getDeviceCount();\n\n\n\n\ngetDevices()\n\n\nGets available device descriptors on the given platform.\n\n\n\n\ngetDevices()\n\n\n\n\nResult: Array\n - array of \ndevice descriptors\n \n\n\ngetDevice()\n\n\nGet the current device ID. \n\n\n\n\ngetDevice()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: Number\n - current device ID\n\n\nsetDevice()\n\n\nChange current device to specified device.\n\n\n\n\nsetDevice(id)\n: \n-\n ArrayFire Documentation\n \n\n\n\n\ndeviceInfo()\n\n\nGet the current device's descriptor. \n\n\n\n\ndeviceInfo()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: object\n - fields\n\n\n\n\nname: String\n - device's vendor specified name\n\n\nplatform: String\n - ID of the platform (CPU, OpenCL, CUDA)\n\n\ntoolkit: String\n - device's vendor specified platform name\n\n\ncompute: String\n - device's vendor specified version\n\n\nisDoubleAvailable: Boolean\n - is double precision supported\n\n\n\n\nisDoubleAvailable()\n\n\nCheck if double precision support is available for specified device. \n\n\n\n\nisDoubleAvailable(deviceID)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArgments:\n\n\n\n\ndeviceID: Number\n - device's ID\n\n\n\n\nResult: Booean\n - is double precision supported\n\n\nsync()\n\n\nasynchronous, counterparts: \nsyncAsync\n, \nsyncSync\n\n\nWaits until all operations on device are finished. \n\n\n\n\nsync()\n: \n-\n ArrayFire Documentation\n\n\n\n\nwait()\n\n\nalias of \nsync()\n\n\nalloc()\n\n\nAllocates memory on the device.\n\n\n\n\nalloc(elements, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nelements: Number\n - number of elements to allocate\n\n\ntype: value of \ndType\n - type of the elements, can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult: Buffer\n - device memory pointer\n\n\nRemarks:\n Deallocation is handled by the GC automatically\n\n\npinned()\n\n\nAllocates pinned memory on the host by using ArrayFire's memory manager.\n\n\n\n\npinned(elements, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nelements: Number\n - number of elements to allocate\n\n\ntype: value of \ndType\n - type of the elements, can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult: Buffer\n - memory pointer\n\n\nRemarks:\n Deallocation is handled by the GC automatically", 
            "title": "Platform and Device managing"
        }, 
        {
            "location": "/devices/#platform-and-device-managing", 
            "text": "-  ArrayFire Documentation     Selecting Platform  getDeviceCount()  getDevices()  getDevice()  setDevice()  deviceInfo()  isDoubleAvailable()  sync()  wait()  alloc()  pinned()", 
            "title": "Platform and Device managing"
        }, 
        {
            "location": "/devices/#selecting-platform", 
            "text": "Fire.js platform can be selected by calling the root function with the appropriate platform ID as an argument.  Supported platform IDs:   CPU  (cpu fallback)  OpenCL  CUDA   Example:  var fire = require( fire-js );\nvar cpuPlatform = fire( CPU );", 
            "title": "Selecting Platform"
        }, 
        {
            "location": "/devices/#getdevicecount", 
            "text": "Gets the number of devices on the given platform.   getDeviceCount() :  -  ArrayFire Documentation   Result: Number  - number of devices  Example:  var fire = require( fire-js );\nvar cpuPlatform = fire( CPU );\nvar deviceCount = cpuPlatform.getDeviceCount();", 
            "title": "getDeviceCount()"
        }, 
        {
            "location": "/devices/#getdevices", 
            "text": "Gets available device descriptors on the given platform.   getDevices()   Result: Array  - array of  device descriptors", 
            "title": "getDevices()"
        }, 
        {
            "location": "/devices/#getdevice", 
            "text": "Get the current device ID.    getDevice() :  -  ArrayFire Documentation   Result: Number  - current device ID", 
            "title": "getDevice()"
        }, 
        {
            "location": "/devices/#setdevice", 
            "text": "Change current device to specified device.   setDevice(id) :  -  ArrayFire Documentation", 
            "title": "setDevice()"
        }, 
        {
            "location": "/devices/#deviceinfo", 
            "text": "Get the current device's descriptor.    deviceInfo() :  -  ArrayFire Documentation   Result: object  - fields   name: String  - device's vendor specified name  platform: String  - ID of the platform (CPU, OpenCL, CUDA)  toolkit: String  - device's vendor specified platform name  compute: String  - device's vendor specified version  isDoubleAvailable: Boolean  - is double precision supported", 
            "title": "deviceInfo()"
        }, 
        {
            "location": "/devices/#isdoubleavailable", 
            "text": "Check if double precision support is available for specified device.    isDoubleAvailable(deviceID) :  -  ArrayFire Documentation   Argments:   deviceID: Number  - device's ID   Result: Booean  - is double precision supported", 
            "title": "isDoubleAvailable()"
        }, 
        {
            "location": "/devices/#sync", 
            "text": "asynchronous, counterparts:  syncAsync ,  syncSync  Waits until all operations on device are finished.    sync() :  -  ArrayFire Documentation", 
            "title": "sync()"
        }, 
        {
            "location": "/devices/#wait", 
            "text": "alias of  sync()", 
            "title": "wait()"
        }, 
        {
            "location": "/devices/#alloc", 
            "text": "Allocates memory on the device.   alloc(elements, type) :  -  ArrayFire Documentation   Arguments:   elements: Number  - number of elements to allocate  type: value of  dType  - type of the elements, can be one of the values of dType object (eg.  dType.f32 )   Result: Buffer  - device memory pointer  Remarks:  Deallocation is handled by the GC automatically", 
            "title": "alloc()"
        }, 
        {
            "location": "/devices/#pinned", 
            "text": "Allocates pinned memory on the host by using ArrayFire's memory manager.   pinned(elements, type) :  -  ArrayFire Documentation   Arguments:   elements: Number  - number of elements to allocate  type: value of  dType  - type of the elements, can be one of the values of dType object (eg.  dType.f32 )   Result: Buffer  - memory pointer  Remarks:  Deallocation is handled by the GC automatically", 
            "title": "pinned()"
        }, 
        {
            "location": "/create/", 
            "text": "Functions to create arrays\n\n\n-\n ArrayFire Documentation\n\n\n\n\n\n\n\n\n\n\nrandu()\n\n\nrandU()\n\n\nrandn()\n\n\nrandN()\n\n\nidentity()\n\n\nrange()\n\n\niota()\n\n\ndiag()\n\n\nconstant()\n\n\n\n\n\n\n\nrandu()\n\n\nCreate a random array sampled from uniform distribution.\n\n\n\n\nrandu(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrandU()\n\n\nalias of \nrandu()\n\n\nrandn()\n\n\nCreate a random array sampled from normal distribution.\n\n\n\n\nrandn(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrandN()\n\n\nalias of \nrandn()\n\n\nidentity()\n\n\nCreate an identity matrix (array with diagonal values 1).\n\n\n\n\nidentity(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrange()\n\n\nCreates an array with [0, n] values along the seqDim which is tiled across other dimensions.\n\n\n\n\nrange(dim0, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, dim2, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, dim2, dim3, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dims, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nseqDim: Number\n - dimension along which [0, dim[seqDim] - 1] is generated, default is -1, which means the last specified dimension \n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\niota()\n\n\nCreate an sequence [0, dims.elements - 1] and modify to specified dimensions dims and then tile it according to tileDims.\n\n\n\n\niota(dims, tileDims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\n\n\n\n\n- **dims: Array\n\n\nDim4\n** - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\n\n\n\n\n\n\n\n\n- \ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\n\n\n\n\n\n\nResult\n: the created AFArray instance.\n\n\ndiag()\n\n\nExtract diagonal from a matrix when \nextract\n is set to \ntrue\n. \n\n\nCreate a diagonal marix from input array when \nextract\n is set to \nfalse\n.\n\n\n\n\ndiag(in, num, extract)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nin: AFArray\n - input array\n\n\nnum: Number\n - diagonal index\n\n\nextract: Boolean\n - when true returns an array containing diagonal of tha matrix and when false returns a matrix with in as diagonal\n\n\n\n\nconstant()\n\n\nCreate an array filled with the specified value.\n\n\n\n\nconstant(value, dim0, type)\n\n\nconstant(value, dim0, dim1, type)\n\n\nconstant(value, dim0, dim1, dim2, type)\n\n\nconstant(value, dim0, dim1, dim2, dim3, type)\n\n\nconstant(value, dims, type)\n\n\n\n\nArguments:\n\n\n\n\nvalue: Number|\nComplex\n|String\n\n\nNumber:\n number\n\n\nComplex\n:\n complex value\n\n\nString:\n: number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.", 
            "title": "Functions to create arrays"
        }, 
        {
            "location": "/create/#functions-to-create-arrays", 
            "text": "-  ArrayFire Documentation     randu()  randU()  randn()  randN()  identity()  range()  iota()  diag()  constant()", 
            "title": "Functions to create arrays"
        }, 
        {
            "location": "/create/#randu", 
            "text": "Create a random array sampled from uniform distribution.   randu(dim0, type) :  -  ArrayFire Documentation  randu(dim0, dim1, type) :  -  ArrayFire Documentation  randu(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  randu(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  randu(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "randu()"
        }, 
        {
            "location": "/create/#randu_1", 
            "text": "alias of  randu()", 
            "title": "randU()"
        }, 
        {
            "location": "/create/#randn", 
            "text": "Create a random array sampled from normal distribution.   randn(dim0, type) :  -  ArrayFire Documentation  randn(dim0, dim1, type) :  -  ArrayFire Documentation  randn(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  randn(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  randn(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "randn()"
        }, 
        {
            "location": "/create/#randn_1", 
            "text": "alias of  randn()", 
            "title": "randN()"
        }, 
        {
            "location": "/create/#identity", 
            "text": "Create an identity matrix (array with diagonal values 1).   identity(dim0, type) :  -  ArrayFire Documentation  identity(dim0, dim1, type) :  -  ArrayFire Documentation  identity(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  identity(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  identity(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "identity()"
        }, 
        {
            "location": "/create/#range", 
            "text": "Creates an array with [0, n] values along the seqDim which is tiled across other dimensions.   range(dim0, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, dim2, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, dim2, dim3, seqDim, type) :  -  ArrayFire Documentation  range(dims, seqDim, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  seqDim: Number  - dimension along which [0, dim[seqDim] - 1] is generated, default is -1, which means the last specified dimension   type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "range()"
        }, 
        {
            "location": "/create/#iota", 
            "text": "Create an sequence [0, dims.elements - 1] and modify to specified dimensions dims and then tile it according to tileDims.   iota(dims, tileDims, type) :  -  ArrayFire Documentation   Arguments:     - **dims: Array  Dim4 ** - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)      -  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )      Result : the created AFArray instance.", 
            "title": "iota()"
        }, 
        {
            "location": "/create/#diag", 
            "text": "Extract diagonal from a matrix when  extract  is set to  true .   Create a diagonal marix from input array when  extract  is set to  false .   diag(in, num, extract) :  -  ArrayFire Documentation   Arguments:   in: AFArray  - input array  num: Number  - diagonal index  extract: Boolean  - when true returns an array containing diagonal of tha matrix and when false returns a matrix with in as diagonal", 
            "title": "diag()"
        }, 
        {
            "location": "/create/#constant", 
            "text": "Create an array filled with the specified value.   constant(value, dim0, type)  constant(value, dim0, dim1, type)  constant(value, dim0, dim1, dim2, type)  constant(value, dim0, dim1, dim2, dim3, type)  constant(value, dims, type)   Arguments:   value: Number| Complex |String  Number:  number  Complex :  complex value  String: : number value (to workaround JavaScript inability to hold int64 values)    dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "constant()"
        }, 
        {
            "location": "/helpers/", 
            "text": "Helper function for arrays\n\n\n-\n ArrayFire Documentation\n\n\n\n\n\n\n\n\n\n\niszero()\n\n\nisZero()\n\n\nisInf()\n\n\nisNaN()\n\n\n\n\n\n\n\niszero()\n\n\nCheck if values are zero. \n\n\n\n\niszero()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is zero, and 0 otherwise.\n\n\nisZero()\n\n\nalias of \niszero()\n\n\nisInf()\n\n\nCheck if values are infinite. \n\n\n\n\nisInf()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is infinity, and 0 otherwise.\n\n\nisNaN()\n\n\nCheck if values are Nan. \n\n\n\n\nisNaN()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is NaN, and 0 otherwise.", 
            "title": "Helper function for arrays"
        }, 
        {
            "location": "/helpers/#helper-function-for-arrays", 
            "text": "-  ArrayFire Documentation     iszero()  isZero()  isInf()  isNaN()", 
            "title": "Helper function for arrays"
        }, 
        {
            "location": "/helpers/#iszero", 
            "text": "Check if values are zero.    iszero()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is zero, and 0 otherwise.", 
            "title": "iszero()"
        }, 
        {
            "location": "/helpers/#iszero_1", 
            "text": "alias of  iszero()", 
            "title": "isZero()"
        }, 
        {
            "location": "/helpers/#isinf", 
            "text": "Check if values are infinite.    isInf()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is infinity, and 0 otherwise.", 
            "title": "isInf()"
        }, 
        {
            "location": "/helpers/#isnan", 
            "text": "Check if values are Nan.    isNaN()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is NaN, and 0 otherwise.", 
            "title": "isNaN()"
        }
    ]
}