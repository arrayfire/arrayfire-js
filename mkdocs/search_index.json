{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n.\n\n\nAbout Fire.js\n\n\nFire.js is the Node.js bindings for ArrayFire. Install instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. First, install a good promise library. I use \nBluebird\n.\n\n\nIt can promisify all functions with node style callbacks:\n\n\nlet Bluebird = require(\nbluebird\n);\n\nlet fire = Bluebird.promisifyAll(require(\nfire-js\n)(\nOpenCL\n));\n\n\n\n\nWrap an \nES6 generator function\n by a coroutine, and you can yield promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have!\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nSimple Example\n\n\n...", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome .", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-firejs", 
            "text": "Fire.js is the Node.js bindings for ArrayFire. Install instructions can be found in the  project's readme at Github .", 
            "title": "About Fire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. First, install a good promise library. I use  Bluebird .  It can promisify all functions with node style callbacks:  let Bluebird = require( bluebird );\n\nlet fire = Bluebird.promisifyAll(require( fire-js )( OpenCL ));  Wrap an  ES6 generator function  by a coroutine, and you can yield promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have!  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#simple-example", 
            "text": "...", 
            "title": "Simple Example"
        }, 
        {
            "location": "/afArray/", 
            "text": "Head 1\n\n\nHead 2\n\n\nHead 3", 
            "title": "AFArray"
        }, 
        {
            "location": "/afArray/#head-1", 
            "text": "", 
            "title": "Head 1"
        }, 
        {
            "location": "/afArray/#head-2", 
            "text": "", 
            "title": "Head 2"
        }, 
        {
            "location": "/afArray/#head-3", 
            "text": "", 
            "title": "Head 3"
        }, 
        {
            "location": "/devices/", 
            "text": "Head 1\n\n\nHead 2\n\n\nHead 3", 
            "title": "Managing Devices"
        }, 
        {
            "location": "/devices/#head-1", 
            "text": "", 
            "title": "Head 1"
        }, 
        {
            "location": "/devices/#head-2", 
            "text": "", 
            "title": "Head 2"
        }, 
        {
            "location": "/devices/#head-3", 
            "text": "", 
            "title": "Head 3"
        }
    ]
}