{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n. It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.\n\n\nAbout Fire.js\n\n\nFire.js is the Node.js bindings for ArrayFire, it uses \nCMake.js\n as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).\n\n\nInstall instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with \n\"Sync\"\n (eg. \nsqrtSync\n). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a \nBluebird promise\n, ends with \n\"Async\"\n (eg. \nsqrtAsync\n). Wrap an \nES6 generator function\n by a \ncoroutine\n, and you can yield those promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have! (Of course you can use some other coroutine library, like \nco\n.)\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nAPI\n\n\nIn Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.\n\n\nAll asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with \nAsync\n and \nSync\n endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.\n\n\nSmall Example\n\n\nPort of the PI calculator from \nArrayFire documentation\n:\n\n\nC++\n\n\n// sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum\nfloat\n(dist \n 1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);\n\n\n\n\nJavaScript\n\n\nconst numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);\n\n\n\n\nIt's included in the \nexamples folder\n. To run on:\n\n\n\n\nio.js, enter: \niojs examples/es6/bechmarks/pi.js\n\n\nNode.js 0.12 or above, enter: \nnode --harmony examples/es6/bechmarks/pi.js\n\n\nNode.js below 0.12, enter: \nnode examples/es5/bechmarks/pi.js\n\n\n\n\nLicense\n\n\nApache 2.0\n\n\nCopyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken\n\nLicensed under the Apache License, Version 2.0 (the \nLicense\n);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \nAS IS\n BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome . It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-firejs", 
            "text": "Fire.js is the Node.js bindings for ArrayFire, it uses  CMake.js  as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).  Install instructions can be found in the  project's readme at Github .", 
            "title": "About Fire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with  \"Sync\"  (eg.  sqrtSync ). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a  Bluebird promise , ends with  \"Async\"  (eg.  sqrtAsync ). Wrap an  ES6 generator function  by a  coroutine , and you can yield those promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have! (Of course you can use some other coroutine library, like  co .)  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#api", 
            "text": "In Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.  All asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with  Async  and  Sync  endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.", 
            "title": "API"
        }, 
        {
            "location": "/#small-example", 
            "text": "Port of the PI calculator from  ArrayFire documentation :  C++  // sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum float (dist   1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);  JavaScript  const numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);  It's included in the  examples folder . To run on:   io.js, enter:  iojs examples/es6/bechmarks/pi.js  Node.js 0.12 or above, enter:  node --harmony examples/es6/bechmarks/pi.js  Node.js below 0.12, enter:  node examples/es5/bechmarks/pi.js", 
            "title": "Small Example"
        }, 
        {
            "location": "/#license", 
            "text": "Apache 2.0  Copyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken\n\nLicensed under the Apache License, Version 2.0 (the  License );\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an  AS IS  BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/statics/", 
            "text": "Static Objects\n\n\nThey are accessible from the main Fire.js context object, eg.:\n\n\nvar fire = require(\nfire-js\n)(\nCPU\n);\n\n// dType:\nvar dType = fire.types.dType;\n\n\n\n\ntypes.dType\n\n\nalias: \ntypes.dtype\n\n\n{\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}\n\n\n\n\ntypes.source\n\n\n{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "Statics"
        }, 
        {
            "location": "/statics/#static-objects", 
            "text": "They are accessible from the main Fire.js context object, eg.:  var fire = require( fire-js )( CPU );\n\n// dType:\nvar dType = fire.types.dType;", 
            "title": "Static Objects"
        }, 
        {
            "location": "/statics/#typesdtype", 
            "text": "alias:  types.dtype  {\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}", 
            "title": "types.dType"
        }, 
        {
            "location": "/statics/#typessource", 
            "text": "{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "types.source"
        }, 
        {
            "location": "/AFArray/", 
            "text": "AFArray class\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\nasynchronous, counterparts: \ncreateAsync\n, \ncreateSync\n\n\nCreates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the \nsource\n argument specifies its location.\n\n\n\n\ncreate(dim0, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim3, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim4, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dims, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nconstructor\n\n\nArrays could be created as empty ones or by having a specified dimensions and element type. \n\n\n\n\nnew AFArray()\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nRemarks:\n\n\nIn Fire.js \ntype\n argument is \nnot optional\n.\n\n\nMethods\n\n\nelements()\n\n\nGet the number of elements in array.\n\n\n\n\nelements()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n Number\n\n\nhost()\n\n\nCopy array data to host.\n\n\nasynchronous, counterparts: \nhostAsync\n, \nhostSync\n\n\n\n\nhost(callback)\n \n-\n ArrayFire Documentation\n\n\nhost(buffer, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - to hold array's values, must be atleast the size of the array.\n\n\n\n\nResult:\n if buffer is not specified, then it will be created and returned, otherwise the result is \nundefined\n\n\ncopyToHost()\n\n\nalias of \nhost\n\n\nwrite\n\n\nPerform deep copy from host/device pointer to an existing array.\n\n\n\n\nwrite(buffer, bytesToCopy, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - data to copy to the array, or device pointer created by the \nalloc\n method.\n\n\nbytesToCopy\n: bytes to copy\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\ntype\n\n\n\n\ntype()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's element type, can be one of the values of \ndType\n object\n\n\ndims\n\n\n\n\ndims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's dimensions info in a \nDim4\n object instance\n\n\nnumdims\n\n\n\n\nnumdims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n number of dimensions of the array\n\n\nnumDims\n\n\nalias of \nnumdims\n\n\nbytes\n\n\n\n\nbytes()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n size of the array in bytes\n\n\ncopy\n\n\n\n\ncopy()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n new AFArray instance holding a deep copy of the array\n\n\nisempty, isscalar, isvector, isrow, iscolumn, iscomplex, isreal, isdouble, issingle, isrealfloating, isfloating, isinteger, isbool\n\n\naliases respectively: \nisEmpty\n, \nisScalar\n, \nisVector\n, \nisRow\n, \nisColumn\n, \nisComplex\n, \nisReal\n, \nisDouble\n, \nisSingle\n, \nisRealFloating\n, \nisFloating\n, \nisInteger\n, \nisBool\n \n\n\n\n\nis\nanything\n() \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n actual type info (Boolean)\n\n\neval\n\n\n\n\neval() \n-\n ArrayFire Documentation\n\n\n\n\nEvaluate any JIT expressions to generate data for the array.\n\n\nIndexing Operations\n\n\nat\n\n\nrow\n\n\ncol\n\n\nslice\n\n\nrows\n\n\ncols\n\n\nslices\n\n\nOperators\n\n\nas\n\n\nassign\n\n\nset\n\n\nadd\n\n\naddAssign\n\n\nsub\n\n\nsubAssign\n\n\nmul\n\n\nmulAssign\n\n\ndiv\n\n\ndivAssign\n\n\nbitshiftl\n\n\nbitShiftL\n\n\nbitshiftr\n\n\nbitShiftR\n\n\nlt\n\n\ngt\n\n\nle\n\n\nge\n\n\neq\n\n\nneq\n\n\nand\n\n\nor\n\n\nneg\n\n\nnot\n\n\nbitAnd\n\n\nbitOr\n\n\nbitXor", 
            "title": "AFArray"
        }, 
        {
            "location": "/AFArray/#afarray-class", 
            "text": "", 
            "title": "AFArray class"
        }, 
        {
            "location": "/AFArray/#staitc-methods", 
            "text": "AFArray.create()  asynchronous, counterparts:  createAsync ,  createSync  Creates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the  source  argument specifies its location.   create(dim0, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim3, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim4, buffer, source, callback)   -  ArrayFire Documentation  create(dims, buffer, source, callback)   -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of  source  - can be one of the values of source object (eg.  source.host )   Result : the created AFArray instance.", 
            "title": "Staitc methods"
        }, 
        {
            "location": "/AFArray/#constructor", 
            "text": "Arrays could be created as empty ones or by having a specified dimensions and element type.    new AFArray() :  -  ArrayFire Documentation  new AFArray(dim0, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  new AFArray(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Remarks:  In Fire.js  type  argument is  not optional .", 
            "title": "constructor"
        }, 
        {
            "location": "/AFArray/#methods", 
            "text": "elements()  Get the number of elements in array.   elements()   -  ArrayFire Documentation   Result:  Number  host()  Copy array data to host.  asynchronous, counterparts:  hostAsync ,  hostSync   host(callback)   -  ArrayFire Documentation  host(buffer, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - to hold array's values, must be atleast the size of the array.   Result:  if buffer is not specified, then it will be created and returned, otherwise the result is  undefined  copyToHost()  alias of  host  write  Perform deep copy from host/device pointer to an existing array.   write(buffer, bytesToCopy, source, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - data to copy to the array, or device pointer created by the  alloc  method.  bytesToCopy : bytes to copy  source: value of  source  - can be one of the values of source object (eg.  source.host )   type   type()   -  ArrayFire Documentation   Result:  array's element type, can be one of the values of  dType  object  dims   dims()   -  ArrayFire Documentation   Result:  array's dimensions info in a  Dim4  object instance  numdims   numdims()   -  ArrayFire Documentation   Result:  number of dimensions of the array  numDims  alias of  numdims  bytes   bytes()   -  ArrayFire Documentation   Result:  size of the array in bytes  copy   copy()   -  ArrayFire Documentation   Result:  new AFArray instance holding a deep copy of the array  isempty, isscalar, isvector, isrow, iscolumn, iscomplex, isreal, isdouble, issingle, isrealfloating, isfloating, isinteger, isbool  aliases respectively:  isEmpty ,  isScalar ,  isVector ,  isRow ,  isColumn ,  isComplex ,  isReal ,  isDouble ,  isSingle ,  isRealFloating ,  isFloating ,  isInteger ,  isBool     is anything ()  -  ArrayFire Documentation   Result:  actual type info (Boolean)  eval   eval()  -  ArrayFire Documentation   Evaluate any JIT expressions to generate data for the array.", 
            "title": "Methods"
        }, 
        {
            "location": "/AFArray/#indexing-operations", 
            "text": "at  row  col  slice  rows  cols  slices", 
            "title": "Indexing Operations"
        }, 
        {
            "location": "/AFArray/#operators", 
            "text": "as  assign  set  add  addAssign  sub  subAssign  mul  mulAssign  div  divAssign  bitshiftl  bitShiftL  bitshiftr  bitShiftR  lt  gt  le  ge  eq  neq  and  or  neg  not  bitAnd  bitOr  bitXor", 
            "title": "Operators"
        }, 
        {
            "location": "/Dim4/", 
            "text": "Dim4 class\n\n\nconstructors\n\n\n\n\nnew Dim4(dimArray)\n\n\nnew Dim4(dim0, dim1, dim2, dim3)\n\n\n\n\nArguments\n:\n\n\n\n\ndimArray: Array\n - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]\n\n\ndim0 .. dim3: Number\n - size of the dimension, default is 1\n\n\n\n\nProperties\n\n\ndims\n\n\nValue:\n \nArray\n containing the dimension sizes, eg.: two dimensions = \n[2, 3, 1, 1]\n, four dimensions = \n[2, 3, 4, 5]\n\n\nndims\n\n\nalias: \nnDims\n\n\nValue:\n number of dimensions\n\n\nelements\n\n\nValue:\n number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Dim4"
        }, 
        {
            "location": "/Dim4/#dim4-class", 
            "text": "", 
            "title": "Dim4 class"
        }, 
        {
            "location": "/Dim4/#constructors", 
            "text": "new Dim4(dimArray)  new Dim4(dim0, dim1, dim2, dim3)   Arguments :   dimArray: Array  - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]  dim0 .. dim3: Number  - size of the dimension, default is 1", 
            "title": "constructors"
        }, 
        {
            "location": "/Dim4/#properties", 
            "text": "dims  Value:   Array  containing the dimension sizes, eg.: two dimensions =  [2, 3, 1, 1] , four dimensions =  [2, 3, 4, 5]  ndims  alias:  nDims  Value:  number of dimensions  elements  Value:  number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Properties"
        }, 
        {
            "location": "/devices/", 
            "text": "Head 1\n\n\nHead 2\n\n\nHead 3", 
            "title": "Managing Devices"
        }, 
        {
            "location": "/devices/#head-1", 
            "text": "", 
            "title": "Head 1"
        }, 
        {
            "location": "/devices/#head-2", 
            "text": "", 
            "title": "Head 2"
        }, 
        {
            "location": "/devices/#head-3", 
            "text": "", 
            "title": "Head 3"
        }
    ]
}