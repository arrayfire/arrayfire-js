"use strict";
var assert = require("better-assert");
var _ = require("lodash");
var ref = require("ref");
var Bluebird = require("bluebird");
var async = Bluebird.coroutine;
var int = ref.types.int;
var float = ref.types.float;
function testPlatform(id) {
  if (process.env["TEST_" + id] === "1") {
    describe(id + " platform", function() {
      var af = require("../..")(id);
      describe("randu", function() {
        it("should yield uniform random int array with 2 dimensions", function(done) {
          var f = async($traceurRuntime.initGeneratorFunction(function $__0() {
            var array,
                data,
                i,
                v;
            return $traceurRuntime.createGeneratorInstance(function($ctx) {
              while (true)
                switch ($ctx.state) {
                  case 0:
                    array = af.randu(2, 4, af.dType.s32);
                    $ctx.state = 6;
                    break;
                  case 6:
                    $ctx.state = 2;
                    return array.copyToHostAsync();
                  case 2:
                    data = $ctx.sent;
                    $ctx.state = 4;
                    break;
                  case 4:
                    assert(data instanceof Buffer);
                    assert(data.length == 2 * 4 * int.size);
                    for (i = 0; i < data.length / int.size; i++) {
                      v = int.get(data, i * int.size);
                      assert(v >= Number.MIN_SAFE_INTEGER && v <= Number.MAX_SAFE_INTEGER);
                      assert(Math.floor(v) === v);
                    }
                    $ctx.state = -2;
                    break;
                  default:
                    return $ctx.end();
                }
            }, $__0, this);
          }));
          f().nodeify(done);
        });
        it("should yield uniform random float array with 2 dimensions", function(done) {
          var f = async($traceurRuntime.initGeneratorFunction(function $__0() {
            var array,
                data,
                i,
                v;
            return $traceurRuntime.createGeneratorInstance(function($ctx) {
              while (true)
                switch ($ctx.state) {
                  case 0:
                    array = af.randu([2, 4], af.dType.f32);
                    $ctx.state = 6;
                    break;
                  case 6:
                    $ctx.state = 2;
                    return array.copyToHostAsync();
                  case 2:
                    data = $ctx.sent;
                    $ctx.state = 4;
                    break;
                  case 4:
                    assert(data instanceof Buffer);
                    assert(data.length == 2 * 4 * float.size);
                    for (i = 0; i < data.length / float.size; i++) {
                      v = float.get(data, i * float.size);
                      assert(v === 0 || v === 1.0 || (v > 0 && v < 1.0 && v % 1));
                    }
                    $ctx.state = -2;
                    break;
                  default:
                    return $ctx.end();
                }
            }, $__0, this);
          }));
          f().nodeify(done);
        });
      });
      describe("randf", function() {
        it("should throw error when invoking normal random int array with 2 dimensions", function() {
          try {
            var array = af.randn(2, 4, af.dType.s32);
            return;
          } catch (e) {
            if (/invalid dtype argument/ig.test(e.message)) {
              return;
            } else {
              throw new Error("This should throw appropriate error.");
            }
          }
          throw new Error("This should throw.");
        });
        it("should yield normal random float array with 2 dimensions", function(done) {
          var f = async($traceurRuntime.initGeneratorFunction(function $__0() {
            var array,
                data,
                i,
                v;
            return $traceurRuntime.createGeneratorInstance(function($ctx) {
              while (true)
                switch ($ctx.state) {
                  case 0:
                    array = af.randn([2, 4], af.dType.f32);
                    $ctx.state = 6;
                    break;
                  case 6:
                    $ctx.state = 2;
                    return array.copyToHostAsync();
                  case 2:
                    data = $ctx.sent;
                    $ctx.state = 4;
                    break;
                  case 4:
                    assert(data instanceof Buffer);
                    assert(data.length == 2 * 4 * float.size);
                    for (i = 0; i < data.length / float.size; i++) {
                      v = float.get(data, i * float.size);
                      assert(v === 0 || (v > -4.0 && v < 4.0 && v % 1));
                    }
                    $ctx.state = -2;
                    break;
                  default:
                    return $ctx.end();
                }
            }, $__0, this);
          }));
          f().nodeify(done);
        });
      });
      describe("identity", function() {
        it("should be implemented", function() {
          console.log(("TODO: implement identity test for " + id + "\n"));
        });
      });
      describe("range", function() {
        it("should be implemented", function() {
          console.log(("TODO: implement range test for " + id + "\n"));
        });
      });
      describe("iota", function() {
        it("should be implemented", function() {
          console.log(("TODO: implement iota test for " + id + "\n"));
        });
      });
      describe("diag", function() {
        it("should be implemented", function() {
          console.log(("TODO: implement diag test for " + id + "\n"));
        });
      });
      describe("constant", function() {
        it("should be implemented", function() {
          console.log(("TODO: implement constant test for " + id + "\n"));
        });
      });
    });
  }
}
describe("Functions to create arrays", function() {
  testPlatform("CPU");
  testPlatform("OpenCL");
  testPlatform("CUDA");
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZUFycmF5RnVuY3Rpb25UZXN0cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErQkE7QUFFQSxBQUFJLEVBQUEsQ0FBQSxNQUFLLEVBQUksQ0FBQSxPQUFNLEFBQUMsQ0FBQyxlQUFjLENBQUMsQ0FBQztBQUNyQyxBQUFJLEVBQUEsQ0FBQSxDQUFBLEVBQUksQ0FBQSxPQUFNLEFBQUMsQ0FBQyxRQUFPLENBQUMsQ0FBQztBQUN6QixBQUFJLEVBQUEsQ0FBQSxHQUFFLEVBQUksQ0FBQSxPQUFNLEFBQUMsQ0FBQyxLQUFJLENBQUMsQ0FBQztBQUN4QixBQUFJLEVBQUEsQ0FBQSxRQUFPLEVBQUksQ0FBQSxPQUFNLEFBQUMsQ0FBQyxVQUFTLENBQUMsQ0FBQztBQUNsQyxBQUFJLEVBQUEsQ0FBQSxLQUFJLEVBQUksQ0FBQSxRQUFPLFVBQVUsQ0FBQztBQUM5QixBQUFJLEVBQUEsQ0FBQSxHQUFFLEVBQUksQ0FBQSxHQUFFLE1BQU0sSUFBSSxDQUFDO0FBQ3ZCLEFBQUksRUFBQSxDQUFBLEtBQUksRUFBSSxDQUFBLEdBQUUsTUFBTSxNQUFNLENBQUM7QUFFM0IsT0FBUyxhQUFXLENBQUcsRUFBQztBQUNwQixLQUFJLE9BQU0sSUFBSSxDQUFFLE9BQU0sRUFBSSxHQUFDLENBQUMsSUFBTSxJQUFFLENBQUc7QUFDbkMsV0FBTyxBQUFDLENBQUMsRUFBQyxFQUFJLFlBQVUsQ0FBRyxVQUFVLEFBQUQ7QUFDaEMsQUFBSSxRQUFBLENBQUEsRUFBQyxFQUFJLENBQUEsT0FBTSxBQUFDLENBQUMsT0FBTSxDQUFDLEFBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztBQUU3QixhQUFPLEFBQUMsQ0FBQyxPQUFNLENBQUcsVUFBVSxBQUFEO0FBQ3ZCLFNBQUMsQUFBQyxDQUFDLHlEQUF3RCxDQUFHLFVBQVUsSUFBRztBQUN2RSxBQUFJLFlBQUEsQ0FBQSxDQUFBLEVBQUksQ0FBQSxLQUFJLEFBQUMsQ0FoRGpDLGVBQWMsc0JBQXNCLEFBQUMsQ0FnREgsY0FBVSxB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dEIsYUFBVyxBQUFDLENBQUMsTUFBSyxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDO0FBQUEiLCJmaWxlIjoiY3JlYXRlQXJyYXlGdW5jdGlvblRlc3RzLmpzIiwic291cmNlUm9vdCI6InRlc3RzL2VzNiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgQXJyYXlGaXJlXG5Db3B5cmlnaHQgKGMpIDIwMTUgR8OhYm9yIE1lesWRIGFrYSB1bmJvcm5jaGlra2VuIChnYWJvci5tZXpvQG91dGxvb2suY29tKVxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIEFycmF5RmlyZSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5cInVzZSBzdHJpY3RcIjtcblxubGV0IGFzc2VydCA9IHJlcXVpcmUoXCJiZXR0ZXItYXNzZXJ0XCIpO1xubGV0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xubGV0IHJlZiA9IHJlcXVpcmUoXCJyZWZcIik7XG5sZXQgQmx1ZWJpcmQgPSByZXF1aXJlKFwiYmx1ZWJpcmRcIik7XG5sZXQgYXN5bmMgPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5sZXQgaW50ID0gcmVmLnR5cGVzLmludDtcbmxldCBmbG9hdCA9IHJlZi50eXBlcy5mbG9hdDtcblxuZnVuY3Rpb24gdGVzdFBsYXRmb3JtIChpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudltcIlRFU1RfXCIgKyBpZF0gPT09IFwiMVwiKSB7XG4gICAgICAgIGRlc2NyaWJlKGlkICsgXCIgcGxhdGZvcm1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IGFmID0gcmVxdWlyZShcIi4uLy4uXCIpKGlkKTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoXCJyYW5kdVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXQoXCJzaG91bGQgeWllbGQgdW5pZm9ybSByYW5kb20gaW50IGFycmF5IHdpdGggMiBkaW1lbnNpb25zXCIsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gYXN5bmMoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFycmF5ID0gYWYucmFuZHUoMiwgNCwgYWYuZFR5cGUuczMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgYXJyYXkuY29weVRvSG9zdEFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YS5sZW5ndGggPT0gMiAqIDQgKiBpbnQuc2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLyBpbnQuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IGludC5nZXQoZGF0YSwgaSAqIGludC5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodiA+PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAmJiB2IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoTWF0aC5mbG9vcih2KSA9PT0gdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmKCkubm9kZWlmeShkb25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdChcInNob3VsZCB5aWVsZCB1bmlmb3JtIHJhbmRvbSBmbG9hdCBhcnJheSB3aXRoIDIgZGltZW5zaW9uc1wiLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZiA9IGFzeW5jKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IGFmLnJhbmR1KFsyLCA0XSwgYWYuZFR5cGUuZjMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgYXJyYXkuY29weVRvSG9zdEFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YS5sZW5ndGggPT0gMiAqIDQgKiBmbG9hdC5zaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAvIGZsb2F0LnNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBmbG9hdC5nZXQoZGF0YSwgaSAqIGZsb2F0LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2ID09PSAwIHx8IHYgPT09IDEuMCB8fCAodiA+IDAgJiYgdiA8IDEuMCAmJiB2ICUgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZigpLm5vZGVpZnkoZG9uZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoXCJyYW5kZlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXQoXCJzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBpbnZva2luZyBub3JtYWwgcmFuZG9tIGludCBhcnJheSB3aXRoIDIgZGltZW5zaW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJyYXkgPSBhZi5yYW5kbigyLCA0LCBhZi5kVHlwZS5zMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvaW52YWxpZCBkdHlwZSBhcmd1bWVudC9pZy50ZXN0KGUubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNob3VsZCB0aHJvdyBhcHByb3ByaWF0ZSBlcnJvci5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgdGhyb3cuXCIpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXQoXCJzaG91bGQgeWllbGQgbm9ybWFsIHJhbmRvbSBmbG9hdCBhcnJheSB3aXRoIDIgZGltZW5zaW9uc1wiLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZiA9IGFzeW5jKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IGFmLnJhbmRuKFsyLCA0XSwgYWYuZFR5cGUuZjMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgYXJyYXkuY29weVRvSG9zdEFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YS5sZW5ndGggPT0gMiAqIDQgKiBmbG9hdC5zaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAvIGZsb2F0LnNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBmbG9hdC5nZXQoZGF0YSwgaSAqIGZsb2F0LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2ID09PSAwIHx8ICh2ID4gLTQuMCAmJiB2IDwgNC4wICYmIHYgJSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmKCkubm9kZWlmeShkb25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZShcImlkZW50aXR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpdChcInNob3VsZCBiZSBpbXBsZW1lbnRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRPRE86IGltcGxlbWVudCBpZGVudGl0eSB0ZXN0IGZvciAke2lkfVxcbmApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKFwicmFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGl0KFwic2hvdWxkIGJlIGltcGxlbWVudGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVE9ETzogaW1wbGVtZW50IHJhbmdlIHRlc3QgZm9yICR7aWR9XFxuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoXCJpb3RhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpdChcInNob3VsZCBiZSBpbXBsZW1lbnRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRPRE86IGltcGxlbWVudCBpb3RhIHRlc3QgZm9yICR7aWR9XFxuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoXCJkaWFnXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpdChcInNob3VsZCBiZSBpbXBsZW1lbnRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRPRE86IGltcGxlbWVudCBkaWFnIHRlc3QgZm9yICR7aWR9XFxuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoXCJjb25zdGFudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXQoXCJzaG91bGQgYmUgaW1wbGVtZW50ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUT0RPOiBpbXBsZW1lbnQgY29uc3RhbnQgdGVzdCBmb3IgJHtpZH1cXG5gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmRlc2NyaWJlKFwiRnVuY3Rpb25zIHRvIGNyZWF0ZSBhcnJheXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRlc3RQbGF0Zm9ybShcIkNQVVwiKTtcbiAgICB0ZXN0UGxhdGZvcm0oXCJPcGVuQ0xcIik7XG4gICAgdGVzdFBsYXRmb3JtKFwiQ1VEQVwiKTtcbn0pOyJdfQ==
