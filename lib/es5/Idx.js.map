{"version":3,"sources":["../es6/Idx.js"],"names":["_","require","fastcall","assert","Seq","Col","Cols","Row","Rows","helpers","Idx","af","idx","arguments","indices","_lib","arrays","IndexArray","type","ndims","args","_parseIndexArgs","lib","i","length","arg","set","seqIndex","span","isNumber","index","firstIndex","lastIndex","structs","IndexT","arr","getHandle","isSeq","isBatch","_batch","seq","data","buffer","module","exports"],"mappings":"AAAA;;;;;;AACA,IAAMA,IAAIC,QAAQ,QAAR,CAAV;AACA,IAAMC,WAAWD,QAAQ,UAAR,CAAjB;AACA,IAAME,SAASF,QAAQ,QAAR,CAAf;AACA,IAAMG,MAAMH,QAAQ,OAAR,CAAZ;AACA,IAAMI,MAAMJ,QAAQ,OAAR,CAAZ;AACA,IAAMK,OAAOL,QAAQ,QAAR,CAAb;AACA,IAAMM,MAAMN,QAAQ,OAAR,CAAZ;AACA,IAAMO,OAAOP,QAAQ,QAAR,CAAb;AACA,IAAMQ,UAAUR,QAAQ,WAAR,CAAhB;;IAEMS,G;;;+BACYC,E,EAAI;AACdA,eAAGC,GAAH,GAAS,YAAY;AACjB,0DAAWF,GAAX,iBAAeC,EAAf,8BAAsBE,SAAtB;AACH,aAFD;AAGH;;;AAED,iBAAYF,EAAZ,EAAyB;AAAA;;AACrB,aAAKG,OAAL,GAAeH,GAAGI,IAAH,CAAQC,MAAR,CAAeC,UAAf,CAA0BC,IAA1B,CAA+B,CAA/B,CAAf;AACA,aAAKC,KAAL,GAAa,CAAb;;AAFqB,0CAANC,IAAM;AAANA,gBAAM;AAAA;;AAGrB,aAAKC,eAAL,CAAqBV,EAArB,EAAyBS,IAAzB;AACH;;;;wCAMeT,E,EAAIS,I,EAAM;AACtB,gBAAME,MAAMX,GAAGI,IAAf;AACA,gBAAIQ,IAAI,CAAR;AACA,mBAAOA,IAAIH,KAAKI,MAAhB,EAAwBD,GAAxB,EAA6B;AACzB,oBAAME,MAAML,KAAKG,CAAL,CAAZ;AACA,oBAAIE,eAAerB,GAAnB,EAAwB;AACpB,yBAAKU,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAASF,GAAT,CAApB;AACH,iBAFD,MAGK,IAAIA,QAAQd,GAAGiB,IAAf,EAAqB;AACtB,yBAAKd,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAT,CAApB;AACH,iBAFI,MAGA,IAAIJ,EAAE6B,QAAF,CAAWJ,GAAX,CAAJ,EAAqB;AACtB,yBAAKX,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQqB,GAAR,CAAT,CAApB;AACH,iBAFI,MAGA,IAAIA,eAAelB,GAAnB,EAAwB;AACzB,yBAAKO,OAAL,CAAaY,GAAb,CAAiBH,GAAjB,EAAsBI,SAAS,IAAIvB,GAAJ,CAAQqB,IAAIK,KAAZ,CAAT,CAAtB;AACA,yBAAKhB,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAT,CAApB;AACH,iBAHI,MAIA,IAAIqB,eAAejB,IAAnB,EAAyB;AAC1B,yBAAKM,OAAL,CAAaY,GAAb,CAAiBH,GAAjB,EAAsBI,SAAS,IAAIvB,GAAJ,CAAQqB,IAAIM,UAAZ,EAAwBN,IAAIO,SAA5B,CAAT,CAAtB;AACA,yBAAKlB,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAT,CAApB;AACH,iBAHI,MAIA,IAAIqB,eAAepB,GAAnB,EAAwB;AACzB,yBAAKS,OAAL,CAAaY,GAAb,CAAiBH,GAAjB,EAAsBI,SAAS,IAAIvB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAT,CAAtB;AACA,yBAAKU,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQqB,IAAIK,KAAZ,CAAT,CAApB;AACH,iBAHI,MAIA,IAAIL,eAAenB,IAAnB,EAAyB;AAC1B,yBAAKQ,OAAL,CAAaY,GAAb,CAAiBH,GAAjB,EAAsBI,SAAS,IAAIvB,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAT,CAAtB;AACA,yBAAKU,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBI,SAAS,IAAIvB,GAAJ,CAAQqB,IAAIM,UAAZ,EAAwBN,IAAIO,SAA5B,CAAT,CAApB;AACH,iBAHI,MAIA;AACD;AACA,yBAAKlB,OAAL,CAAaY,GAAb,CAAiBH,CAAjB,EAAoBD,IAAIW,OAAJ,CAAYC,MAAZ,CAAmBhB,IAAnB,CAAwB;AACxCN,6BAAK;AACDuB,iCAAK1B,QAAQ2B,SAAR,CAAkBX,GAAlB;AADJ,yBADmC;AAIxCY,+BAAO,KAJiC;AAKxCC,iCAAS3B,GAAG4B;AAL4B,qBAAxB,CAApB;AAOH;AACJ;;AAEDpC,mBAAOoB,IAAI,CAAJ,IAASA,KAAK,CAArB,EAAwB,0BAAxB;AACA,iBAAKJ,KAAL,GAAaI,CAAb;;AAEA,qBAASI,QAAT,CAAkBa,GAAlB,EAAuB;AACnB,uBAAOlB,IAAIW,OAAJ,CAAYC,MAAZ,CAAmBhB,IAAnB,CAAwB;AAC3BN,yBAAK;AACD4B,6BAAKA,IAAIC;AADR,qBADsB;AAI3BJ,2BAAO,IAJoB;AAK3BC,6BAAS3B,GAAG4B;AALe,iBAAxB,CAAP;AAOH;AACJ;;;4BA1DY;AACT,mBAAO,KAAKzB,OAAL,CAAa4B,MAApB;AACH;;;;;;AA2DLC,OAAOC,OAAP,GAAiBlC,GAAjB","file":"Idx.js","sourcesContent":["'use strict';\nconst _ = require('lodash');\nconst fastcall = require('fastcall');\nconst assert = require('assert');\nconst Seq = require('./Seq');\nconst Col = require('./Col');\nconst Cols = require('./Cols');\nconst Row = require('./Row');\nconst Rows = require('./Rows');\nconst helpers = require('./helpers');\n\nclass Idx {\n    static define(af) {\n        af.idx = function () {\n            return new Idx(af, ...arguments);\n        };\n    }\n\n    constructor(af, ...args) {\n        this.indices = af._lib.arrays.IndexArray.type(4);\n        this.ndims = 0;\n        this._parseIndexArgs(af, args);\n    }\n\n    get buffer() {\n        return this.indices.buffer;\n    }\n\n    _parseIndexArgs(af, args) {\n        const lib = af._lib;\n        let i = 0;\n        for (; i < args.length; i++) {\n            const arg = args[i];\n            if (arg instanceof Seq) {\n                this.indices.set(i, seqIndex(arg));\n            }\n            else if (arg === af.span) {\n                this.indices.set(i, seqIndex(new Seq(1, 1, 0)));\n            }\n            else if (_.isNumber(arg)) {\n                this.indices.set(i, seqIndex(new Seq(arg)));\n            }\n            else if (arg instanceof Row) {\n                this.indices.set(i++, seqIndex(new Seq(arg.index)));\n                this.indices.set(i, seqIndex(new Seq(1, 1, 0)));\n            }\n            else if (arg instanceof Rows) {\n                this.indices.set(i++, seqIndex(new Seq(arg.firstIndex, arg.lastIndex)));\n                this.indices.set(i, seqIndex(new Seq(1, 1, 0)));\n            }\n            else if (arg instanceof Col) {\n                this.indices.set(i++, seqIndex(new Seq(1, 1, 0)));\n                this.indices.set(i, seqIndex(new Seq(arg.index)));\n            }\n            else if (arg instanceof Cols) {\n                this.indices.set(i++, seqIndex(new Seq(1, 1, 0)));\n                this.indices.set(i, seqIndex(new Seq(arg.firstIndex, arg.lastIndex)));\n            }\n            else {\n                // AFArray\n                this.indices.set(i, lib.structs.IndexT.type({\n                    idx: {\n                        arr: helpers.getHandle(arg)\n                    },\n                    isSeq: false,\n                    isBatch: af._batch\n                }));\n            }\n        }\n\n        assert(i > 0 && i <= 4, 'Invalid index arguments.');\n        this.ndims = i;\n\n        function seqIndex(seq) {\n            return lib.structs.IndexT.type({\n                idx: {\n                    seq: seq.data\n                },\n                isSeq: true,\n                isBatch: af._batch\n            });\n        }\n    }\n}\n\nmodule.exports = Idx;"]}